/*
 * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{
    classHeader = "CopyrightHeader.txt"

    implements = "io.ballerina.plugins.idea.psi.BallerinaCompositeElement"
    extends = "io.ballerina.plugins.idea.psi.impl.BallerinaCompositeElementImpl"

    parserClass = "io.ballerina.plugins.idea.parser.BallerinaParser"
    parserUtilClass="io.ballerina.plugins.idea.parser.BallerinaParserUtil"

    psiClassPrefix = "Ballerina"
    psiImplClassSuffix = "Impl"
    psiPackage = "io.ballerina.plugins.idea.psi"
    psiImplPackage = "io.ballerina.plugins.idea.psi.impl"
    psiImplUtilClass = "io.ballerina.plugins.idea.psi.impl.BallerinaPsiImplUtil"

    elementTypeHolderClass = "io.ballerina.plugins.idea.psi.BallerinaTypes"
    elementTypeClass = "io.ballerina.plugins.idea.psi.BallerinaCompositeElementType"

    tokenTypeClass = "io.ballerina.plugins.idea.psi.BallerinaTokenType"

    tokens = [

        DOCUMENTATION       = 'documentation';
        DEPRECATED          = 'deprecated';

        // Separators
        SEMICOLON           = ';' ;
        COLON               = ':' ;
        DOUBLE_COLON        = '::' ;
        DOT                 = '.' ;
        COMMA               = ',' ;
        LEFT_BRACE          = '{' ;
        RIGHT_BRACE         = '}' ;
        LEFT_PARENTHESIS    = '(' ;
        RIGHT_PARENTHESIS   = ')' ;
        LEFT_BRACKET        = '[' ;
        RIGHT_BRACKET       = ']' ;
        QUESTION_MARK       = '?' ;

        // Arithmetic operators
        ASSIGN              = '=' ;
        ADD                 = '+' ;
        SUB                 = '-' ;
        MUL                 = '*' ;
        DIV                 = '/' ;
        POW                 = '^' ;
        MOD                 = '%';

        // Relational operators
        NOT                 = '!' ;
        EQUAL               = '==' ;
        NOT_EQUAL           = '!=' ;
        GT                  = '>' ;
        LT                  = '<' ;
        GT_EQUAL            = '>=' ;
        LT_EQUAL            = '<=' ;
        AND                 = '&&' ;
        OR                  = '||' ;

        // Additional symbols
        RARROW              = '->' ;
        LARROW              = '<-' ;
        AT                  = '@' ;
        BACKTICK            = '`' ;
        RANGE               = '..' ;
        ELLIPSIS            = '...' ;
        PIPE                = '|' ;
        EQUAL_GT            = '=>' ;

        // Compound Assignment operators.
        COMPOUND_ADD        = '+=' ;
        COMPOUND_SUB        = '-=' ;
        COMPOUND_MUL        = '*=' ;
        COMPOUND_DIV        = '/=' ;

        // Safe assignment operator
        SAFE_ASSIGNMENT     = '=?' ;

        // Post Arithmetic operators.
        INCREMENT           = '++' ;
        DECREMENT           = '--' ;

        LINE_COMMENT        = 'regexp://[^\r\n]*'

        WHITE_SPACE = 'regexp:\s+'
        identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DECIMAL_INTEGER_LITERAL = "regexp:\d+"

        //        QUOTED_STRING_LITERAL = "regexp:\"(.*?)\""
        //        INTEGER_LITERAL = "regexp:\d+"


        //    string_template_literal_start = "regexp:string\s*`"
        //    string_template_literal_end = "`"

        //    string_template_expression_start = "{{"
        //    string_template_expression_end = "}}"
  ]

    extends("(FunctionInvocation|SimpleVariable|MapArrayVariable|FieldVariable|XmlAttribVariable|Invocation|AwaitExpression)Reference") = VariableReference

    extends("((Simple|Array|Record|Xml|StringTemplate)Literal|(ValueType|BuiltInReferenceType)Type|VariableReference|LambdaFunction|TypeInit|Type(Casting|Conversion|Access)|BracedOrTuple|Await|TableQuery|MatchExpr|Checked|TableLiteral|Elvis|ActionInvocation|typeAccess|IntegerRange)Expression") = Expression
    extends("(Unary|Binary|Ternary|Bitwise|BitwiseShift)Expression") = Expression

    extends("Binary(DivMulMod|AddSub|Compare|Equal|And|Or)Expression") = BinaryExpression

    extends("(Simple|Array|Nullable|Union|Group|Tuple|Annotated|Object|Record)TypeName|BinaryAndExpression") = TypeName

    // Each named definition which can be renamed should implement this interface.
    implements("(Function|Struct|GlobalVariable|Annotation|(.*Endpoint)|Action|Worker|Type)Definition") = "io.ballerina.plugins.idea.psi.BallerinaNamedElement"
    // This is to identify top level elements in a file.
    implements("(Function|Struct|GlobalVariable|Annotation|(.*Endpoint)|Action|Worker|Type)Definition") = "io.ballerina.plugins.idea.psi.impl.BallerinaTopLevelDefinition"
    // Each named definition should extend this class.
    extends("(Function|Struct|GlobalVariable|Annotation|(.*Endpoint)|Action|Worker|Type)Definition") = "io.ballerina.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"

    // Each stubbed element should have this element type factory.
    elementTypeFactory("(Function|Struct|GlobalVariable|Annotation|(.*Endpoint)|Action|Worker|Type)Definition") = "io.ballerina.plugins.idea.stubs.factory.BallerinaElementTypeFactory.stubFactory"

    // Each stub which is not a named definition should extend this class.
//    extends("PackageDeclaration") = "BallerinaStubbedElementImpl<?>"

    // "|NamespaceDeclaration|ParameterList|ParameterTypeNameList|CallableUnitSignature|ParameterTypeNameList|ReturnParameters"
    // Todo - Add CatchClause, TriggerWorker, WorkerReply?
    // Each named element (which can be renamed) should implement this interface.
    implements("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|VariableDefinitionStatement|NamespaceDeclaration") = "io.ballerina.plugins.idea.psi.BallerinaNamedElement"
    // Each named element should extend this class.
    extends("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|VariableDefinitionStatement|NamespaceDeclaration") = "io.ballerina.plugins.idea.psi.impl.BallerinaNamedElementImpl<?>"
    // Each stubbed element should have this element type factory.
    elementTypeFactory("Package(Name|Version)|OrgName|Alias|(Name|Package)Reference|VariableDefinitionStatement|NamespaceDeclaration") = "io.ballerina.plugins.idea.stubs.factory.BallerinaElementTypeFactory.stubFactory"

    implements("NameReference") = "io.ballerina.plugins.idea.psi.BallerinaReferenceExpressionBase"

    generateTokenAccessors = true
}

CompilationUnit ::=(ImportDeclaration | NamespaceDeclaration)* (DefinitionWithoutAnnotationAttachments |  DefinitionWithMultipleAnnotationAttachments | DefinitionWithSingleAnnotationAttachment)* <<eof>>

DefinitionWithMultipleAnnotationAttachments ::= documentationAttachment? deprecatedAttachment? AnnotationAttachment AnnotationAttachment+ Definition {pin=4 elementType=Definition}
DefinitionWithSingleAnnotationAttachment ::= documentationAttachment? deprecatedAttachment? AnnotationAttachment Definition {pin=3 elementType=Definition}
DefinitionWithoutAnnotationAttachments ::= documentationAttachment? deprecatedAttachment? Definition {elementType=Definition}

//PackageDeclaration ::= package CompletePackageName PackageVersion? SEMICOLON {
//    pin=1
//    methods=[getName]
//    stubClass="io.ballerina.plugins.idea.stubs.BallerinaPackageDeclarationStub"
//}

CompletePackageName ::= PackageName (DOT PackageName)* {
    pin(".*")=1
    methods=[getReferences]
}

PackageName ::= identifier {
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaPackageNameStub"
}

PackageVersion ::= version identifier {
    pin=1
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaPackageVersionStub"
}

// Todo - Cache
ImportDeclaration ::= import (OrgName DIV)? CompletePackageName PackageVersion? Alias? SEMICOLON {
    pin=1
    methods=[getShortPackageName]
}

OrgName ::= identifier {
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaOrgNameStub"
}

Alias ::= as identifier {
    pin=1 stubClass="io.ballerina.plugins.idea.stubs.BallerinaAliasStub"
}

// Note - Global variable definition should be the first definition since it can contain identifier as type.
Definition ::= ( TypeDefinition
               | GlobalVariableDefinition
               | ServiceDefinition
               | FunctionDefinition
               | AnnotationDefinition
               | GlobalEndpointDefinition
               ) {
    recoverWhile=TopLevelDefinitionRecover
}

private TopLevelDefinitionRecover ::= !(DOCUMENTATION_TEMPLATE_START|DEPRECATED_TEMPLATE_START|'@'|native|public|type|typedesc|service|function|enum|annotation|endpoint|record|int|float|boolean|string|byte|map|xml|xmlns|json|table|any|stream|object|future|identifier|'{')

ServiceDefinition ::= service (LT NameReference GT)? identifier ServiceEndpointAttachments?  ServiceBody {pin=1}
ServiceEndpointAttachments ::= bind (NameReference (COMMA NameReference)* | RecordLiteral) {pin=1}
ServiceBody ::= LEFT_BRACE (/*ResourceDefinition+ | EndpointDefinition+ ResourceDefinition* |*/ EndpointDefinition* (VariableDefinitionStatementInService | NamespaceDeclarationStatement)* ResourceDefinition*) RIGHT_BRACE /*{pin=1}*/

// Note - Always sync with VariableDefinitionStatement
VariableDefinitionStatementInService ::= /*<<isNotAResourceDefinition>> VariableDefinitionStatement*/ TypeName identifier VariableAssignment? SEMICOLON {pin(".*")=2 elementType=VariableDefinitionStatement}
ResourceDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? identifier LEFT_PARENTHESIS resourceParameterList? RIGHT_PARENTHESIS CallableUnitBody {pin=4}
resourceParameterList ::= endpointParameter | ParameterList
endpointParameter ::= endpoint identifier (COMMA ParameterList)? {pin(".*")=1}

// Pin to make sure callable unit is identified correctly
// Note - Empty body was added to fix issue in anon object function
CallableUnitBody ::= LEFT_BRACE (RIGHT_BRACE | BlockWithEndpoint RIGHT_BRACE | BlockWithEndpointAndWorker RIGHT_BRACE)  {pin=1}

Block ::= Statement* {methods=[processDeclarations]} /*{recoverWhile=StatementRecover}*/
BlockWithEndpoint ::= EndpointDefinition* Statement* {elementType=Block}
BlockWithEndpointAndWorker ::= EndpointDefinition* WorkerDefinition+ {elementType=Block}
NonEmptyBlock ::= Statement+ {elementType=Block}
//private StatementRecover ::= !(int | string | '}' | '=')

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /* switch | var | continue |try |*/ int )

// Todo - Need getIdentifier?
FunctionDefinition ::= (public)? (native)? function (FunctionWithoutReceiver | FunctionWithReceiver) {
    pin=3 methods=[getIdentifier getName] stubClass="io.ballerina.plugins.idea.stubs.BallerinaFunctionDefinitionStub"
}
private FunctionWithReceiver ::=  (TypeName DOUBLE_COLON)? CallableUnitSignature (CallableUnitBody | SEMICOLON) {pin=2}
private FunctionWithoutReceiver ::= AttachedObject DOUBLE_COLON CallableUnitSignature CallableUnitBody {pin=2}

AttachedObject ::= identifier

LambdaFunction ::= LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS EQUAL_GT LambdaReturnParameter? CallableUnitBody {pin=4}

// Todo - cache and add Signature owner?
CallableUnitSignature ::= AnyIdentifierName LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS ReturnParameter? {pin=1}

TypeDefinition ::= (public)? type identifier FiniteType SEMICOLON {
    pin=2
    methods=[getName]
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaTypeDefinitionStub"
}

ObjectBody ::= ObjectFieldDefinition* ObjectInitializer? ObjectFunctions?

ObjectInitializer ::= AnnotationAttachment* documentationAttachment? (public)? new ObjectInitializerParameterList CallableUnitBody {pin=4}

ObjectInitializerParameterList ::= LEFT_PARENTHESIS ObjectParameterList? RIGHT_PARENTHESIS {pin=1}

ObjectFunctions ::= ObjectFunctionDefinition+

ObjectFieldDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? (public | private)? TypeName identifier (ASSIGN Expression)? (COMMA | SEMICOLON) {pin=5}

FieldDefinition ::= AnnotationAttachment* TypeName identifier (ASSIGN Expression)? (COMMA | SEMICOLON) {pin=3}

RecordRestFieldDefinition ::= TypeName <<restDescriptorPredicate>> ELLIPSIS | SealedLiteral

SealedLiteral ::= NOT <<restDescriptorPredicate>> ELLIPSIS

ObjectParameterList ::= (ObjectDefaultableParameter | ObjectParameter) (COMMA (ObjectDefaultableParameter | ObjectParameter))* (COMMA RestParameter)? | RestParameter

// Todo - Revert back the changes?
ObjectParameter ::= AnnotationAttachment* (TypeName identifier | identifier)

ObjectDefaultableParameter ::= ObjectParameter ASSIGN Expression

ObjectFunctionDefinition ::= AnnotationAttachment* documentationAttachment? deprecatedAttachment? (public)? (native)? function CallableUnitSignature (CallableUnitBody | SEMICOLON) {pin=6}

//TODO merge with callableUnitSignature later
ObjectCallableUnitSignature ::= AnyIdentifierName LEFT_PARENTHESIS FormalParameterList? RIGHT_PARENTHESIS ReturnParameter? {pin=1}


AnnotationDefinition ::= (public)? annotation (LT AttachmentPoint (COMMA AttachmentPoint)* GT)? identifier UserDefineTypeName? SEMICOLON {
    pin=2
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaAnnotationDefinitionStub"
}

//private AttachmentPointsRecover ::= !(GT | Identifier | SEMICOLON)

GlobalVariableDefinition ::= (public)? TypeName identifier (ASSIGN  Expression)? SEMICOLON {
    pin=2
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaGlobalVariableDefinitionStub"
}

// Todo - Need to update the service?
// Note - "parameter" is treated differently here because there is a parser rule named "parameter" as well.
AttachmentPoint ::= service | resource | function | object | type | endpoint | TYPE_PARAMETER | annotation {
    /*recoverWhile=AttachmentPointRecover*/
}

// Todo - Rename as declaration
WorkerDefinition ::= worker identifier WorkerBody {
    pin=1
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaWorkerDefinitionStub"
    recoverWhile=WorkerDefinitionRecover
}

private WorkerDefinitionRecover ::= !(worker|'}')

WorkerBody ::= LEFT_BRACE Block RIGHT_BRACE {pin=1}

GlobalEndpointDefinition ::= public? EndpointDefinition {
    pin=2
    methods=[getIdentifier] stubClass="io.ballerina.plugins.idea.stubs.BallerinaGlobalEndpointDefinitionStub"
}

EndpointDefinition ::= AnnotationAttachment* endpoint EndpointType identifier EndpointInitialization? SEMICOLON {
    pin=2
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaEndpointDefinitionStub"
}

EndpointType ::= NameReference

EndpointInitialization ::= RecordLiteral | ASSIGN VariableReference

FiniteType ::= FiniteTypeUnit (PIPE FiniteTypeUnit)*

FiniteTypeUnit ::= SimpleLiteral | TypeName

//todo
TypeName ::= TupleTypeName
             | SimpleTypeName
             | GroupTypeName
             | ArrayTypeName
             | UnionTypeName
             | ObjectTypeName
//             | AnnotatedTypeName
             | NullableTypeName
             | RecordTypeName

SimpleTypeName ::= NULL_LITERAL
                   | AnyTypeName
                   | TypeDescTypeName
                   | ValueTypeName
                   | ReferenceTypeName
                   | EmptyTupleLiteral
AnyTypeName ::= any
TypeDescTypeName ::= typedesc

//AnnotatedTypeName ::= AnnotationAttachment+ SimpleTypeName
ArrayTypeName ::= TypeName (LEFT_BRACKET (IntegerLiteral | SealedLiteral)? RIGHT_BRACKET)+
NullableTypeName ::= TypeName QUESTION_MARK
UnionTypeName ::= TypeName (PIPE TypeName)+
GroupTypeName ::= LEFT_PARENTHESIS <<isGroupType>> TypeName RIGHT_PARENTHESIS
TupleTypeName ::= LEFT_PARENTHESIS TypeName (COMMA TypeName)* RIGHT_PARENTHESIS
ObjectTypeName ::= object LEFT_BRACE ObjectBody RIGHT_BRACE {pin=1}
RecordTypeName ::= record? LEFT_BRACE RecordFieldDefinitionList RIGHT_BRACE

RecordFieldDefinitionList ::= FieldDefinition* RecordRestFieldDefinition?

//BuiltInTypeName ::= AnyTypeName
//                    | SimpleTypeName (LEFT_BRACKET RIGHT_BRACKET)+
//                    | TypeDescTypeName
//                    | ValueTypeName
//                    | BuiltInReferenceTypeName

ReferenceTypeName ::= BuiltInReferenceTypeName
                      | UserDefineTypeName

UserDefineTypeName ::= NameReference

ValueTypeName ::=   boolean | int | float | string | byte

BuiltInReferenceTypeName ::= MapTypeName
                             | FutureTypeName
                             | XmlTypeName
                             | JsonTypeName
                             | StreamTypeName
                             | TableTypeName
                             | FunctionTypeName
MapTypeName ::= map (LT TypeName GT)? {pin=1}
FutureTypeName ::= future (LT TypeName GT)? {pin=1}
XmlTypeName ::= xml (LT (LEFT_BRACE XmlNamespaceName RIGHT_BRACE)? XmlLocalName GT)? {pin=1}
JsonTypeName ::= json (LT NameReference GT)? {pin=1}
TableTypeName ::= table (LT NameReference GT)? {pin=1}
StreamTypeName ::= stream (LT TypeName GT)? {pin=1}

FunctionTypeName ::= function LEFT_PARENTHESIS (ParameterList | ParameterTypeNameList)? RIGHT_PARENTHESIS ReturnParameter? {pin=3}

XmlNamespaceName ::= QUOTED_STRING_LITERAL

XmlLocalName ::= identifier

// Todo - Cache
AnnotationAttachment ::= AT NameReference RecordLiteral? {pin=1}


// STATEMENTS / BLOCKS =================================================================================================

// Todo - Add recovery rules
// Note - Expression statement should be the first one.
Statement ::=
        WhileStatement
    |   ForeverStatement
    |   ContinueStatement
    |   ForeachStatement
    |   matchStatement
    |   BreakStatement
    |   ThrowStatement
    |   ReturnStatement
    |   AbortStatement
    |   RetryStatement
    |   LockStatement
    |   NamespaceDeclarationStatement
    |   TransactionStatement
    |   IfElseStatement
    |   TryCatchStatement
    |   ForkJoinStatement
    |   tupleDestructuringStatement
    |   WorkerInteractionStatement
    |   AssignmentStatement
    |   VariableDefinitionStatement
    |   CompoundAssignmentStatement
    |   PostIncrementStatement
    |   ExpressionStmt
    |   StreamingQueryStatement
    |   DoneStatement
    |   ScopeStatement
    |   CompensateStatement
{recoverWhile = StatementRecover}

// Todo - Add more tokens
// Note - Literals are added for worker interactions - 10 -> w2;
// NULL_LITERAL is added for match pattern -  null => return "error";
private StatementRecover ::= !(BOOLEAN_LITERAL|QUOTED_STRING_LITERAL|DECIMAL_INTEGER_LITERAL|HEX_INTEGER_LITERAL|OCTAL_INTEGER_LITERAL|BINARY_INTEGER_LITERAL|NULL_LITERAL|int|string|float|boolean|byte|any|json|xml|xmlns|map|table|function|stream|'('|'}'|';'|typedesc|future|await|var|while|match|foreach|continue|break|fork|try|throw|return|abort|retry|fail|lock|transaction|if|forever|object|check|from|worker|done|identifier)

//private StatementRecover ::= !(/*'!' | '&' | '(' | '*' | '+' | '-' |*/ ';' /*| '<-' | '^' | 'type' |*/ /*'{' | '|' |*/ '|=' | '||' | '}' | /*break | case | char | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex |*/ identifier | /* if | interface | map | oct | return | select |*/ string  | /*struct | switch | var | continue |try |*/ int )

// Note - VariableDefinitionStatementInService
VariableDefinitionStatement ::= TypeName identifier VariableAssignment? SEMICOLON {
    pin=2
    // Note - Resource definition cannot be identified correctly with this pin.
    methods=[getType]
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaVariableDefinitionStatementStub"
}

private VariableAssignment ::= ASSIGN Expression {pin=1}

RecordLiteral ::= LEFT_BRACE RecordLiteralBody? RIGHT_BRACE {pin(".*")=1}

RecordLiteralBody ::= (RecordKeyValue (COMMA RecordKeyValue)*){pin(".*")=1}

RecordKeyValue ::= RecordKey COLON Expression {pin=1}

RecordKey ::= Expression | identifier

TableLiteral ::= table LEFT_BRACE TableColumnDefinition? (COMMA TableDataArray)? RIGHT_BRACE {pin=1}

TableColumnDefinition ::= LEFT_BRACE (TableColumn (COMMA TableColumn)*)? RIGHT_BRACE

TableColumn ::= primarykey? identifier

TableDataArray ::= LEFT_BRACKET TableDataList? RIGHT_BRACKET

TableDataList ::=  TableData (COMMA TableData)* | ExpressionList

TableData ::= LEFT_BRACE ExpressionList RIGHT_BRACE

ArrayLiteral ::= LEFT_BRACKET ExpressionList? RIGHT_BRACKET

TypeInitExpr ::= new (UserDefineTypeName (LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS) | (LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS)?) {pin(".*")=1}

AssignmentStatement ::= withVar | withoutVar

private withVar ::= var VariableReference ASSIGN Expression SEMICOLON {pin=1}
private withoutVar ::= VariableReference ASSIGN Expression SEMICOLON {pin=2}

tupleDestructuringStatement ::= var? LEFT_PARENTHESIS VariableReferenceList RIGHT_PARENTHESIS ASSIGN Expression SEMICOLON
                                | LEFT_PARENTHESIS ParameterList RIGHT_PARENTHESIS ASSIGN Expression SEMICOLON

CompoundAssignmentStatement ::= VariableReference CompoundOperator Expression SEMICOLON

CompoundOperator ::= COMPOUND_ADD | COMPOUND_SUB | COMPOUND_MUL | COMPOUND_DIV

PostIncrementStatement ::= VariableReference PostArithmeticOperator SEMICOLON

PostArithmeticOperator ::= INCREMENT | DECREMENT

VariableReferenceList ::= VariableReference (COMMA VariableReference)* {pin(".*")=1}

IfElseStatement ::= IfClause ElseIfClause* ElseClause? /*{pin=1}*/

IfClause ::= if Expression (LEFT_BRACE Block RIGHT_BRACE) {pin(".*")=1}

ElseIfClause ::= else pinnedElseClause
private pinnedElseClause ::= if Expression (LEFT_BRACE Block RIGHT_BRACE) {pin(".*")=1}

ElseClause ::= else (LEFT_BRACE Block RIGHT_BRACE) {pin(".*")=1}

matchStatement ::= match Expression matchStatementBody {pin=1}
matchStatementBody ::= LEFT_BRACE matchPatternClause+ RIGHT_BRACE {pin=1}

// Todo - Add fake rule
matchPatternClause ::= namedPattern | unnamedPattern
unnamedPattern ::= TypeName EQUAL_GT (LEFT_BRACE Block RIGHT_BRACE | Statement) {pin=2}
namedPattern ::= TypeName identifier EQUAL_GT (LEFT_BRACE Block RIGHT_BRACE | Statement) {pin=3}

ForeachStatement ::= foreach (LEFT_PARENTHESIS? VariableReferenceList in Expression RIGHT_PARENTHESIS? (LEFT_BRACE Block RIGHT_BRACE)) {pin(".*")=1}

IntRangeExpression ::= openRange | closedRange
private openRange ::= Expression RANGE Expression {pin=2}
private closedRange ::= (LEFT_BRACKET|LEFT_PARENTHESIS) Expression RANGE Expression (RIGHT_BRACKET|RIGHT_PARENTHESIS) {pin=3}

// Todo - pin 1?
WhileStatement ::= while Expression WhileStatementBody {pin(".*")=1}

WhileStatementBody ::= LEFT_BRACE Block RIGHT_BRACE {pin=1}

ContinueStatement ::= continue SEMICOLON {pin=1}

BreakStatement ::= break SEMICOLON {pin=1}

ScopeStatement ::= ScopeClause CompensationClause

ScopeClause ::= scope identifier LEFT_BRACE Statement* RIGHT_BRACE {pin=1}

CompensationClause ::= compensation CallableUnitBody {pin=1}

CompensateStatement ::= compensate identifier SEMICOLON {pin=1}

// typeName is only message
ForkJoinStatement ::= fork (LEFT_BRACE ForkStatementBody RIGHT_BRACE JoinClause? TimeoutClause?) {pin(".*")=1}

ForkStatementBody ::= WorkerDefinition*

// below typeName is only 'message[]'
JoinClause ::= join (LEFT_PARENTHESIS JoinConditions RIGHT_PARENTHESIS)? (LEFT_PARENTHESIS TypeName identifier (RIGHT_PARENTHESIS JoinClauseBody)) {pin(".*")=1}

JoinClauseBody ::= LEFT_BRACE Block RIGHT_BRACE {pin=1}

// Todo - Needs reorder?
JoinConditions ::= (some IntegerLiteral | all) (identifier (COMMA identifier)*)? {pin(".*")=1 recoverWhile=JoinConditionRecover}

// Todo - Add more tokens. Eg - int
private JoinConditionRecover ::= !(')'|'}')

// below typeName is only 'message[]'
TimeoutClause ::= timeout (LEFT_PARENTHESIS Expression RIGHT_PARENTHESIS (LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS TimeoutClauseBody)) {pin(".*")=1}

TimeoutClauseBody ::= LEFT_BRACE Block RIGHT_BRACE {pin=1}

TryCatchStatement ::= try (LEFT_BRACE Block RIGHT_BRACE CatchClauses) {pin(".*")=1}

CatchClauses ::= CatchClause+ FinallyClause? | FinallyClause

CatchClause ::= catch (LEFT_PARENTHESIS TypeName identifier RIGHT_PARENTHESIS (LEFT_BRACE Block RIGHT_BRACE)) {pin(".*")=1}

FinallyClause ::= finally {LEFT_BRACE Block RIGHT_BRACE} {pin(".*")=1}

ThrowStatement ::= throw Expression SEMICOLON {pin=1}

ReturnStatement ::= return Expression? SEMICOLON {pin=1}

WorkerInteractionStatement ::= TriggerWorker | WorkerReply

// below left identifier is of type TYPE_MESSAGE and the right identifier is of type WORKER
// Note - Cannot pin rarrow since it will mess up action invocation in statementexpr - client -> invoke1(a, a);
TriggerWorker ::=  Expression RARROW (fork | identifier) SEMICOLON /*{pin=2}*/

// below left identifier is of type WORKER and the right identifier is of type message
WorkerReply ::= Expression LARROW identifier SEMICOLON {pin=2}

// Note - Order of 'simpleVariableReference' and 'functionInvocationReference' because otherwise all function
// invocations will match simpleVariableReference first.
VariableReference ::= MapArrayVariableReference
                      | InvocationReference
                      | FieldVariableReference
                      | XmlAttribVariableReference
                      | FunctionInvocationReference
                      | SimpleVariableReference {
  methods=[getType]
}

InvocationReference ::= VariableReference Invocation
MapArrayVariableReference ::= VariableReference Index
FieldVariableReference ::= VariableReference Field
XmlAttribVariableReference ::= VariableReference XmlAttrib
FunctionInvocationReference ::= FunctionInvocation
SimpleVariableReference ::=  NameReference

Field ::= (DOT | NOT) (identifier | MUL) {
    /*pin=1*/
//    stubClass="io.ballerina.plugins.idea.stubs.BallerinaFieldStub"
}

Index ::= LEFT_BRACKET Expression RIGHT_BRACKET /*{pin=1}*/

XmlAttrib ::= AT (LEFT_BRACKET Expression RIGHT_BRACKET)? /*{pin=1}*/

// Todo - Need to pin?
FunctionInvocation ::= functionNameReference LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS {pin=2}

// Todo - Adding pin will mess function invocation.
Invocation ::= (DOT | NOT) AnyIdentifierName LEFT_PARENTHESIS InvocationArgList? RIGHT_PARENTHESIS /*{pin=1}*/

InvocationArgList ::= InvocationArg (COMMA InvocationArg)* {pin(".*")=1}

InvocationArg ::= NamedArgs | RestArgs | Expression

// Todo - Update the recovery rule
ActionInvocation ::= start? NameReference RARROW FunctionInvocation {/*pin=3 recoverWhile=StatementRecover*/}

ExpressionList ::= Expression (COMMA Expression)* {
    pin(".*")=1
//    recoverWhile = ExpressionListRecover
}
//private ExpressionListRecover ::= !(RIGHT_PARENTHESIS | SEMICOLON)

ExpressionStmt ::= Expression SEMICOLON {pin=1}

TransactionStatement ::= TransactionClause OnRetryClause? {pin=1}

TransactionClause ::= transaction (with TransactionPropertyInitStatementList)? (LEFT_BRACE (Block RIGHT_BRACE)) {pin(".*")=1}

TransactionPropertyInitStatement ::= RetriesStatement | OnCommitStatement | OnAbortStatement

TransactionPropertyInitStatementList ::= TransactionPropertyInitStatement (COMMA TransactionPropertyInitStatement)* {pin(".*")=1}

LockStatement ::= lock LEFT_BRACE Block RIGHT_BRACE {pin=1}

OnRetryClause ::= onretry (LEFT_BRACE (Block RIGHT_BRACE)) {pin(".*")=1}

AbortStatement ::= abort SEMICOLON {pin=1}

RetryStatement ::= retry SEMICOLON {pin=1}

RetriesStatement ::= retries ASSIGN Expression {pin=1}

OnCommitStatement ::= oncommit ASSIGN Expression {pin=1}

OnAbortStatement ::= onabort ASSIGN Expression {pin=1}

NamespaceDeclarationStatement ::= NamespaceDeclaration /*{pin=1}*/

NamespaceDeclaration ::= xmlns QUOTED_STRING_LITERAL (as identifier)? SEMICOLON {
    pin=1
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaNamespaceDeclarationStub"
}

Expression
    ::=
        LambdaFunctionExpression
    |   SimpleLiteralExpression
    |   StringTemplateLiteralExpression
    |   XmlLiteralExpression
    |   TableLiteralExpression
    |   RecordLiteralExpression
    |   BracedOrTupleExpression
    |   TernaryExpression
    |   ArrayLiteralExpression
    |   ValueTypeTypeExpression
    |   BuiltInReferenceTypeTypeExpression
    |   ActionInvocationExpression
    |   VariableReferenceExpression
    |   TypeInitExpression
    |   TypeConversionExpression
    |   UnaryExpression
    |   BinaryDivMulModExpression
    |   BinaryAddSubExpression
    |   BinaryCompareExpression
    |   BinaryEqualExpression
    |   BinaryAndExpression
    |   BinaryOrExpression
    |   TableQueryExpression
    |   MatchExprExpression
    |   CheckedExpression
    |   ElvisExpression
    |   AwaitExpression
    |   typeAccessExpression
    |   IntegerRangeExpression
    |   BitwiseExpression
    |   BitwiseShiftExpression
    {recoverWhile=ExpressionRecover}

typeAccessExpression ::= TypeName

ActionInvocationExpression::= ActionInvocation

ElvisExpression::= Expression ELVIS Expression

TableQueryExpression ::= TableQuery

TableLiteralExpression ::= TableLiteral

private ExpressionRecover ::= !(NULL_LITERAL|int|string|float|boolean|byte|any|map|table|function|stream|'}'|';'|var |while|match|foreach|continue|break|fork|try|throw|return|abort|fail|lock|xmlns|transaction|but|if|forever|object|check)

fake BinaryExpression ::= Expression {
  methods=[left="Expression[0]" right="Expression[1]" getOperator]
}

//private ExpressionRecover ::=  !('!' | '!=' | '%' | '%=' | '&&' | '&' | '&=' | '&^' | '&^=' | '(' | ')' | '*' | '*=' | '+' | '++' | '+=' | ',' | '-' | '--' | '-=' | '...' | '/' | '/=' | ':' | ';' | '<' | '<-' | '<<' | '<<=' | '<=' | '<NL>' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '[' | ']' | '^' | '^=' | 'type' | '{' | '|' | '|=' | '||' | '}' | break | case | chan | char | continue | decimali | default | defer | else | fallthrough | float | floati | for | func | go | goto | hex | identifier | if | int | interface | map | oct | return | select | string | raw_string | struct | switch | var )
SimpleLiteralExpression ::= SimpleLiteral
ArrayLiteralExpression ::= ArrayLiteral
RecordLiteralExpression ::= RecordLiteral
XmlLiteralExpression ::= XmlLiteral
StringTemplateLiteralExpression ::= StringTemplateLiteral
ValueTypeTypeExpression ::= ValueTypeName DOT identifier
BuiltInReferenceTypeTypeExpression ::= BuiltInReferenceTypeName DOT identifier
VariableReferenceExpression ::= start? VariableReference
LambdaFunctionExpression ::= LambdaFunction
TypeInitExpression ::= TypeInitExpr
TypeConversionExpression ::= LT TypeName (COMMA FunctionInvocation)? GT Expression {pin=1}
UnaryExpression ::= (ADD | SUB | NOT | lengthof | untaint) Expression {pin=1}
BracedOrTupleExpression ::= LEFT_PARENTHESIS Expression (COMMA Expression)* RIGHT_PARENTHESIS
BinaryDivMulModExpression ::= Expression (DIV | MUL | MOD) Expression
BinaryAddSubExpression ::= Expression (ADD | SUB) Expression
BinaryCompareExpression ::= Expression (LT_EQUAL | GT_EQUAL | GT | LT) Expression
BinaryEqualExpression ::= Expression (EQUAL | NOT_EQUAL) Expression
BinaryAndExpression ::= Expression <<isNotInStreams>> AND Expression
BinaryOrExpression ::= Expression OR Expression
TernaryExpression ::= Expression QUESTION_MARK Expression COLON Expression {pin=2}
AwaitExpression ::= await Expression
MatchExprExpression ::= Expression matchExpression
CheckedExpression ::= check Expression
IntegerRangeExpression ::= Expression (ELLIPSIS | HALF_OPEN_RANGE) Expression
BitwiseExpression ::= Expression (BITAND | PIPE | BITXOR) Expression
BitwiseShiftExpression ::= Expression (ShiftExpression) Expression
matchExpression ::= but (LEFT_BRACE MatchExpressionPatternClause (COMMA MatchExpressionPatternClause)* RIGHT_BRACE) {pin(".*")=1}

ShiftExpression ::= GT <<shiftExprPredicate>> GT
    | LT <<shiftExprPredicate>> LT
    | GT <<shiftExprPredicate>> GT <<shiftExprPredicate>> GT

MatchExpressionPatternClause ::= TypeName identifier? EQUAL_GT Expression {pin=1}

//reusable productions

NameReference ::= <<isPackageExpected>> PackageReference identifier | identifier {
    methods=[/*getReference*/ getQualifier /*resolve*/ resolveType isInLocalPackage]
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaNameReferenceStub"
//    extends=test
//    elementType=test
}

functionNameReference ::= <<isPackageExpected>> PackageReference? AnyIdentifierName {
    methods=[/*getReference*/ getQualifier /*resolve*/ resolveType isInLocalPackage]
}

PackageReference ::= identifier COLON {
    pin=2
    methods=[getReference]
    stubClass="io.ballerina.plugins.idea.stubs.BallerinaPackageReferenceStub"
}

ReturnParameter ::= returns ReturnType {pin=1}
ReturnType ::= AnnotationAttachment* TypeName

LambdaReturnParameter ::= AnnotationAttachment* TypeName

ParameterTypeNameList ::= parameterTypeName (COMMA parameterTypeName)* {pin=1 /*recoverWhile=RecoverParameter*/}

parameterTypeName ::= AnnotationAttachment* TypeName

ParameterList ::= Parameter (COMMA Parameter)* {pin(".*")=1 /*recoverWhile=RecoverParameter*/}

//private RecoverParameter ::= !(string | COMMA | RIGHT_PARENTHESIS | identifier)

// Todo - Add indexing
Parameter ::= SimpleParameter | TupleParameter
private SimpleParameter ::= AnnotationAttachment* parameterWithType /*{pin=2}*/
private TupleParameter ::= AnnotationAttachment* LEFT_PARENTHESIS parameterWithType (COMMA parameterWithType)* RIGHT_PARENTHESIS

parameterWithType ::= <<isNotARestParameter>> TypeName identifier

DefaultableParameter ::= Parameter ASSIGN Expression

RestParameter ::= AnnotationAttachment* TypeName ELLIPSIS identifier {pin=3}

FormalParameterList ::= (DefaultableParameter | Parameter) (COMMA (DefaultableParameter | Parameter))* (COMMA RestParameter)? | RestParameter

SimpleLiteral ::= (ADD|SUB)? IntegerLiteral
                  | (ADD|SUB)? FLOATING_POINT_LITERAL
                  | QUOTED_STRING_LITERAL
                  | BOOLEAN_LITERAL
                  | EmptyTupleLiteral
                  | BlobLiteral
                  | NULL_LITERAL

// §3.10.1 Integer Literals
IntegerLiteral ::= DECIMAL_INTEGER_LITERAL | HEX_INTEGER_LITERAL | OCTAL_INTEGER_LITERAL | BINARY_INTEGER_LITERAL

EmptyTupleLiteral ::= LEFT_PARENTHESIS RIGHT_PARENTHESIS

BlobLiteral ::= BASE_16_BLOB_LITERAL | BASE_64_BLOB_LITERAL

NamedArgs ::= identifier ASSIGN Expression {pin=2}

RestArgs ::= ELLIPSIS Expression {pin=1}

// XML parsing

XmlLiteral ::= XML_LITERAL_START XmlItem XML_LITERAL_END {pin=1}

XmlItem ::= ProcIns | Comment | Element | XmlText | cdata

Content ::= XmlText? ((ProcIns | Comment | Element | cdata) XmlText?)*

Comment ::= XML_COMMENT_START (XML_COMMENT_TEMPLATE_TEXT Expression EXPRESSION_END)* XML_COMMENT_TEXT {pin=1}

Element ::= StartTag Content CloseTag | EmptyTag

StartTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_CLOSE {pin=1}

CloseTag ::= XML_TAG_OPEN_SLASH XmlQualifiedName XML_TAG_CLOSE {pin=1}

EmptyTag ::= XML_TAG_OPEN XmlQualifiedName Attribute* XML_TAG_SLASH_CLOSE {pin=1}

ProcIns ::= XML_TAG_SPECIAL_OPEN (XML_PI_TEMPLATE_TEXT Expression EXPRESSION_END)* XML_PI_TEXT {pin=1}

Attribute ::= XmlQualifiedName EQUALS XmlQuotedString;

XmlText ::= (XML_TEMPLATE_TEXT Expression EXPRESSION_END)+ XML_TEXT_SEQUENCE? | XML_TEXT_SEQUENCE

XmlQuotedString ::= XmlSingleQuotedString | XmlDoubleQuotedString

XmlSingleQuotedString ::= SINGLE_QUOTE (XML_SINGLE_QUOTED_TEMPLATE_STRING Expression EXPRESSION_END)* XML_SINGLE_QUOTED_STRING_SEQUENCE? SINGLE_QUOTE_END

XmlDoubleQuotedString ::= DOUBLE_QUOTE (XML_DOUBLE_QUOTED_TEMPLATE_STRING Expression EXPRESSION_END)* XML_DOUBLE_QUOTED_STRING_SEQUENCE? DOUBLE_QUOTE_END

XmlQualifiedName ::= (XML_QNAME QNAME_SEPARATOR)? XML_QNAME | XML_TAG_EXPRESSION_START Expression EXPRESSION_END

// Todo - Uncomment
StringTemplateLiteral ::= STRING_TEMPLATE_LITERAL_START StringTemplateContent? STRING_TEMPLATE_LITERAL_END {pin=1 /*recoverWhile=StringTemplateLiteralRecover*/}

// Todo - Update to statement recover
/*private StringTemplateLiteralRecover ::= !(SEMICOLON | string | int | identifier)*/

StringTemplateContent ::= StringTemplateExpressionContent | StringTemplateTextContent

private StringTemplateExpressionContent ::= StringTemplateExpression+ STRING_TEMPLATE_TEXT?
private StringTemplateExpression ::= STRING_TEMPLATE_EXPRESSION_START Expression EXPRESSION_END /*{pin=1}*/
private StringTemplateTextContent ::= STRING_TEMPLATE_TEXT

AnyIdentifierName ::= identifier | ReservedWord

ReservedWord ::= foreach | map | start | continue


//Siddhi Streams and Tables related
TableQuery ::= from StreamingInput JoinStreamingInput? SelectClause? OrderByClause? LimitClause? {pin=1}

AggregationQuery ::= from StreamingInput SelectClause? OrderByClause?

DoneStatement ::= done SEMICOLON {pin=1}

// Note - Pinning 1 does not seem to work.
ForeverStatement ::= forever (LEFT_BRACE ForeverStatementBody RIGHT_BRACE) {pin(".*")=1}
ForeverStatementBody ::= StreamingQueryStatement+

StreamingQueryStatement ::= from (StreamingInput (JoinStreamingInput)? | PatternClause)
        SelectClause?
        OrderByClause?
        OutputRateLimit?
        StreamingAction{pin=1}

PatternClause ::= every? PatternStreamingInput WithinClause?

WithinClause ::= within DECIMAL_INTEGER_LITERAL TimeScale {pin=1}

OrderByClause ::= order by OrderByVariable (COMMA OrderByVariable)* {pin=1}

OrderByVariable ::= VariableReference OrderByType?

LimitClause ::= limit DECIMAL_INTEGER_LITERAL {pin=1}

SelectClause ::= select (MUL| SelectExpressionList) GroupByClause? HavingClause? {pin=1}

SelectExpressionList ::= SelectExpression (COMMA SelectExpression)*

SelectExpression ::= Expression (as identifier)?

GroupByClause ::= group by VariableReferenceList {pin=1}

HavingClause ::= having Expression {pin=1}

StreamingAction ::= EQUAL_GT LEFT_PARENTHESIS Parameter RIGHT_PARENTHESIS LEFT_BRACE Block RIGHT_BRACE {pin=1}

SetClause ::= set SetAssignmentClause (COMMA SetAssignmentClause)* {pin=1}

SetAssignmentClause ::= VariableReference ASSIGN Expression

StreamingInput ::= Expression WhereClause? FunctionInvocation* WindowClause? FunctionInvocation* WhereClause? (as identifier)? {pin=1}

JoinStreamingInput ::= (unidirectional JoinType | JoinType unidirectional | JoinType) StreamingInput on Expression

OutputRateLimit ::= output ((all | last | first) every DECIMAL_INTEGER_LITERAL (TimeScale | events)
    | snapshot every DECIMAL_INTEGER_LITERAL TimeScale){pin(".*")=1}

PatternStreamingInput ::=
        Pattern4
    |   Pattern5
    |   Pattern1
    |   Pattern2
    |   Pattern3
    |   PatternStreamingEdgeInput

private Pattern1 ::= PatternStreamingEdgeInput (followed by | COMMA) PatternStreamingInput {pin=2}
private Pattern2 ::= LEFT_PARENTHESIS PatternStreamingInput RIGHT_PARENTHESIS
private Pattern4 ::= NOT PatternStreamingEdgeInput (AND PatternStreamingEdgeInput | for DECIMAL_INTEGER_LITERAL TimeScale) {pin(".*")=1}
private Pattern3 ::= foreach PatternStreamingInput {pin=1}
private Pattern5 ::= PatternStreamingEdgeInput (AND | OR) PatternStreamingEdgeInput {pin=2}

PatternStreamingEdgeInput ::= VariableReference WhereClause? IntRangeExpression? (as identifier)? {pin=1}

WhereClause ::= where Expression {pin=1}

WindowClause ::= window FunctionInvocation  {pin=1}

OrderByType ::= ascending | descending

JoinType ::= left outer join | right outer join | full outer join | outer join | inner? join

TimeScale ::= second | seconds
            | minute | minutes
            | hour | hours
            | day | days
            | month | months
            | year | years

// Deprecated parsing.

deprecatedAttachment ::= DEPRECATED_TEMPLATE_START deprecatedText? DEPRECATED_TEMPLATE_END {pin=1}

deprecatedText ::= deprecatedTemplateInlineCode (DEPRECATED_TEMPLATE_TEXT | deprecatedTemplateInlineCode)*
                   | DEPRECATED_TEMPLATE_TEXT (DEPRECATED_TEMPLATE_TEXT | deprecatedTemplateInlineCode)*

deprecatedTemplateInlineCode ::= singleBackTickDeprecatedInlineCode | doubleBackTickDeprecatedInlineCode | tripleBackTickDeprecatedInlineCode

singleBackTickDeprecatedInlineCode ::= SB_DEPRECATED_INLINE_CODE_START SINGLE_BACK_TICK_INLINE_CODE? SINGLE_BACK_TICK_INLINE_CODE_END {pin=1}

doubleBackTickDeprecatedInlineCode ::= DB_DEPRECATED_INLINE_CODE_START DOUBLE_BACK_TICK_INLINE_CODE? DOUBLE_BACK_TICK_INLINE_CODE_END {pin=1}

tripleBackTickDeprecatedInlineCode ::= TB_DEPRECATED_INLINE_CODE_START TRIPLE_BACK_TICK_INLINE_CODE? TRIPLE_BACK_TICK_INLINE_CODE_END {pin=1}


// Documentation parsing.

documentationAttachment ::= DOCUMENTATION_TEMPLATE_START documentationTemplateContent? DOCUMENTATION_TEMPLATE_END {pin=1}

documentationTemplateContent ::= docText? documentationTemplateAttributeDescription+ | docText

documentationTemplateAttributeDescription ::= DOCUMENTATION_TEMPLATE_ATTRIBUTE_START identifier? DOCUMENTATION_TEMPLATE_ATTRIBUTE_END docText? {pin=1}

docText ::= documentationTemplateInlineCode (DOCUMENTATION_TEMPLATE_TEXT | documentationTemplateInlineCode)*
            | DOCUMENTATION_TEMPLATE_TEXT  (DOCUMENTATION_TEMPLATE_TEXT | documentationTemplateInlineCode)*

documentationTemplateInlineCode ::= singleBackTickDocInlineCode | doubleBackTickDocInlineCode | tripleBackTickDocInlineCode

singleBackTickDocInlineCode ::= SB_DOC_INLINE_CODE_START SINGLE_BACK_TICK_INLINE_CODE? SINGLE_BACK_TICK_INLINE_CODE_END {pin=1}

doubleBackTickDocInlineCode ::= DB_DOC_INLINE_CODE_START DOUBLE_BACK_TICK_INLINE_CODE? DOUBLE_BACK_TICK_INLINE_CODE_END {pin=1}

tripleBackTickDocInlineCode ::= TB_DOC_INLINE_CODE_START TRIPLE_BACK_TICK_INLINE_CODE? TRIPLE_BACK_TICK_INLINE_CODE_END {pin=1}
